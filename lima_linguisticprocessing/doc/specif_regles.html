<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Spécifications du format des règles pour la construction d'automates de reconnaissance d'expressions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="article"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN2"
>Spécifications du format des règles pour la construction d'automates de reconnaissance d'expressions</A
></H1
><H3
CLASS="author"
><A
NAME="AEN3"
>Romaric Besancon</A
></H3
><DIV
CLASS="affiliation"
><DIV
CLASS="address"
><P
CLASS="address"
>&nbsp;CEA-LIST&nbsp;<CODE
CLASS="email"
>&#60;<A
HREF="mailto:romaric.besancon@cea.fr"
>romaric.besancon@cea.fr</A
>&#62;</CODE
></P
></DIV
></DIV
><P
CLASS="copyright"
>Copyright &copy; 2005 Romaric Besançon - CEA-LIST</P
><DIV
CLASS="revhistory"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.1</TD
><TD
ALIGN="LEFT"
>7 fév 2005</TD
><TD
ALIGN="LEFT"
>Revised by: RB</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>reprise du document de spécification préliminaire (en LaTeX)</TD
></TR
></TABLE
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#AEN19"
>Objectif</A
></DT
><DT
>2. <A
HREF="#AEN30"
>Spécifications des règles</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#AEN33"
>Besoin d'expressivité des règles</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#AEN95"
>Format des Règles</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#AEN110"
>formalisme des automates décrivant le contexte</A
></DT
><DD
><DL
><DT
>3.1.1. <A
HREF="#AEN113"
>Unités simples</A
></DT
><DT
>3.1.2. <A
HREF="#AEN249"
>Opérations sur les unités simples</A
></DT
><DT
>3.1.3. <A
HREF="#AEN284"
>Bornes de l'expression</A
></DT
><DT
>3.1.4. <A
HREF="#AEN289"
>Type de l'expression</A
></DT
><DT
>3.1.5. <A
HREF="#AEN364"
>Forme normalisée de l'entité</A
></DT
><DT
>3.1.6. <A
HREF="#AEN412"
>Compléments de syntaxe des fichier de règles</A
></DT
></DL
></DD
><DT
>3.2. <A
HREF="#AEN435"
>Spécification formelle des règles</A
></DT
><DT
>3.3. <A
HREF="#AEN439"
>Limites</A
></DT
><DD
><DL
><DT
>3.3.1. <A
HREF="#AEN442"
>Limites d'expressivité des règles</A
></DT
></DL
></DD
><DT
>3.4. <A
HREF="#AEN462"
>Exemples de règles</A
></DT
><DD
><DL
><DT
>3.4.1. <A
HREF="#AEN465"
>Règles de reconnaissance des entités nommées</A
></DT
><DT
>3.4.2. <A
HREF="#AEN477"
>règles de reconnaissance des expressions idiomatiques</A
></DT
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN19"
>1. Objectif</A
></H2
><P
>&#13;      L'objet de ce document est la définition du format déclaratif de
      règles permettant de reconnaître des expressions dans un texte
      analysé (en cours d'analyse). Cette reconnaissance s'appuie sur
      un format d'expressions régulières qui permet la construction
      d'automates pour la reconnaissance d'expressions particulière.

      Ces automates sont utilisées lors du traitement linguistique
      pour 
      <P
></P
><UL
><LI
><P
>la reconnaissance des expressions idiomatiques</P
></LI
><LI
><P
>la reconnaissance d'entités spécifiques comme les nombres,
          les dates et les entités nommées</P
></LI
><LI
><P
>l'extraction de relations de dépendance pour l'analyse
          syntaxique</P
></LI
></UL
>
    </P
><P
>&#13;    </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN30"
>2. Spécifications des règles</A
></H2
><P
>&#13;    </P
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN33"
>2.1. Besoin d'expressivité des règles</A
></H3
><P
>&#13;        Les éléments nécessaires à la définition des règles pour la
        reconnaissance d'expressions particulères spécifiques sont :
      </P
><P
>&#13;      </P
><P
></P
><UL
><LI
><P
>&#13;            Un <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>élément déclencheur</I
></SPAN
> : c'est
            l'élément qui lancera le processus de reconnaissance
            lorsqu'il apparaît dans un texte ; il sera choisi comme
            l'élément le moins fréquent ou le plus caractéristique de
            l'expression considérée, pour éviter de trop nombreux
            déclenchements qui n'aboutissent pas. Le déclencheur ne doit
            pas forcément être au début de l'expression.
          </P
></LI
><LI
><P
>&#13;            Les <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>contextes gauche et droit</I
></SPAN
> qui
            définissent l'expression autour du déclencheur (on utilise
            les termes "gauche" et "droit" pour désigner les contextes
            "précécent" et "suivant": c'est aussi comme cela que ces
            termes doivent être compris dans une langue comme l'arabe)
            : ces contextes seront définis en utilisant un formalisme
            proche des expressions régulières. Les éléments dont on a
            besoin pour définir ces contextes sont les suivants :
          </P
><P
></P
><UL
><LI
><P
>&#13;                Des unités de reconnaissance : elles peuvent être
                virtuellement n'importe quelle propriété (ou
                combinaison de propriétés) associée à un élément
                unitaire de la phrase en sortie de l'analyse
                morphologique ou après désambiguïsation (un
                <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>FullToken</I
></SPAN
> ou un
                <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>DicoWord</I
></SPAN
>). En pratique, les
                propriétés qui nous semblent a priori intéressantes
                pour la définition des règles sont les suivantes :
              </P
><P
></P
><UL
><LI
><P
>&#13;                    Des mots simples : la reconnaissance se fait alors
                    sur la simple forme de surface (la forme directe
                    du mot dans le texte ou l'une de ses variantes
                    orthographiques obtenue lors de l'analyse
                    morphologique) ;
                  </P
></LI
><LI
><P
>&#13;                    Des catégories grammaticales seules : par exemple
                    pour prendre en compte l'insertion d'un ou
                    plusieurs adjectifs ;
                  </P
></LI
><LI
><P
>&#13;                    Des formes normalisées de mots : la correspondance
                    se fera alors avec toutes les formes fléchies du
                    mot (la catégorie grammaticale du mot doit alors
                    être obligatoirement spécifiée : par exemple
                    "porte" n'acceptera pas les mêmes flexions s'il
                    est nom ou verbe) ;
                  </P
></LI
><LI
><P
>&#13;                    Des classes, qui regroupent un certain nombre de
                    mots ou d'éléments particuliers (définis dans une
                    liste) qui partagent une propriété qui n'est pas
                    identifiée dans le dictionnaire (ce peut être le
                    cas pour des annonceurs de noms propres, par
                    exemple) ;
                  </P
></LI
><LI
><P
>&#13;                    d'autres propriétés peuvent également être
                    envisagées, comme des traits sémantiques ou
                    morphologiques (initiale en majuscule, par exemple),
                    ou des contraintes sur des valeurs numériques ;
                  </P
></LI
></UL
></LI
><LI
><P
>&#13;                Des opérations sur ces unités (opérations classiques
                des expressions régulières) :
              </P
><P
></P
><UL
><LI
><P
>&#13;                    Des groupements de mots : par exemple "de la" peut
                    être considérée comme un groupe à manipuler comme une
                    unité ;
                  </P
></LI
><LI
><P
>&#13;                    Des alternatives d'unités ou de groupes : "M." ou
                    "Monsieur" ;
                  </P
></LI
><LI
><P
>&#13;                    Des cardinalités sur l'occurrence d'une unité ou
                    d'un groupe : on peut introduire un ou deux
                    adverbes dans une forme verbale composée, mais pas
                    plus de trois. On peut également avoir besoin de
                    spécifier une cardinalité non limitée (la limite
                    pourra alors être la limite de la phrase ou du
                    texte, selon l'usage).
                  </P
></LI
><LI
><P
>&#13;                    Des unités ou groupes optionnels : cette propriété
                    est un cas particulier de cardinalité (au moins 0, au
                    plus 1 occurrence), mais on peut la garder pour
                    faciliter l'écriture ;
                  </P
></LI
><LI
><P
>&#13;                    la négation d'une unité ou d'un groupe : on peut
                    vouloir exprimer qu'une unité est reconnue si elle
                    n'a pas une certaine propriété (par exemple,
                    n'importe quel mot sauf un point).
                  </P
></LI
></UL
></LI
></UL
></LI
><LI
><P
>&#13;            Le <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>type</I
></SPAN
> de l'expression reconnue ;
          </P
></LI
><LI
><P
>&#13;            La <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>forme normalisée</I
></SPAN
> de l'expression
            (pour certaines entités dont la forme normalisée doit être
            calculée, comme les nombres ou les dates, un code
            permettant d'indiquer le type de normalisation peut
            également être envisagé) ;
          </P
></LI
><LI
><P
>&#13;            Les <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>bornes de l'expression</I
></SPAN
> reconnue
            ou l'indication de quels mots parmi ceux reconnus ne font
            pas partie de l'expression reconnue : les déclencheurs et
            le contexte peuvent en effet permettre de reconnaître ou
            de caractériser une entité, sans faire partie de cette
            entité ;
          </P
></LI
><LI
><P
>&#13;            Des <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>contraintes</I
></SPAN
> supplémentaires sur
            certains éléments reconnus ou entre certains éléments de
            la règle doivent également pouvoir être spécifiés (par
            exemple des contraintes d'accord en genre, en nombre, en
            personne etc.)
          </P
></LI
><LI
><P
>&#13;            l'indication possible du <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>mot principal</I
></SPAN
> de l'entité reconnue (tête de
            l'expression). Cette indication est particulièrement utile
            pour les expressions idiomatiques. Une expression
            idiomatique peut en effet être fléchie, et les propriétés
            linguistiques associées à l'expression dans son ensemble
            seront alors celles de la tête de l'expression (par
            exemple, la forme pronominale "se trompait" devra être
            reconnue comme une forme verbale à l'imparfait de
            l'indicatif, propriétés linguistiques du mot "trompait",
            tête de l'expression).
          </P
></LI
><LI
><P
>&#13;            l'indication de la <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>relativité d'application</I
></SPAN
> de la règle : également utile
            pour les expressions idiomatiques, cette indication doit
            permettre d'indiquer si la reconnaissance de la règle est
            absolue (par exemple "au fur et à mesure" est
            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>toujours</I
></SPAN
> une expression idiomatique)
            ou est une possibilité à désambiguïser dans une phase
            ultérieure du traitement ("rendez-vous" peut être un mot
            composé ou un verbe suivi d'un pronom).
          </P
></LI
><LI
><P
>&#13;            la possibilité d'indiquer la négation d'un type: si la
            règle s'applique, alors aucune autre règle du type indiqué
            ne devra être appliquée (permet de mieux structurer les
            règles et de contourner ou rattraper facilement certains
            problèmes).
          </P
></LI
></UL
><P
>&#13;      </P
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="AEN95"
>3. Format des Règles</A
></H2
><P
>&#13;      Pour répondre aux besoins d'expressivité des règles spécifiés
      dans la section précédente, le formalisme de règles utilisé
      actuellement est le suivant :
    </P
><P
>&#13;      Le séparateur principal de la règle est le signe
      "<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>:</I
></SPAN
>" Une règle est définie par une
      expression du type :
    </P
><P
>&#13;      <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>&#60;déclencheur&#62;<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>:</I
></SPAN
>&#60;contexte gauche&#62;<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>:</I
></SPAN
>&#60;contexte droit&#62;<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>:</I
></SPAN
>&#60;type d'expression&#62;<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>:</I
></SPAN
>&#60;forme normalisée&#62;</I
></SPAN
>
    </P
><P
>&#13;      Les <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>&#60;contexte gauche&#62;</I
></SPAN
> et
      <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>&#60;contexte droit&#62;</I
></SPAN
> utilisent le
      formalisme définis dans la section suivante.
    </P
><P
>&#13;      Les contraintes sont ajoutées à la suite de ces règles.
    </P
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN110"
>3.1. formalisme des automates décrivant le contexte</A
></H3
><P
>&#13;      </P
><DIV
CLASS="section"
><HR><H4
CLASS="section"
><A
NAME="AEN113"
>3.1.1. Unités simples</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN115"
></A
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Unités</TH
><TH
>azer</TH
></TR
></THEAD
><TBODY
><TR
><TD
>Mots simples</TD
><TD
>mot</TD
></TR
><TR
><TD
>Catégories grammaticales seules</TD
><TD
>$CG</TD
></TR
><TR
><TD
>Formes normalisées de mots</TD
><TD
>lemme$CG</TD
></TR
><TR
><TD
>Propriétés morphologiques</TD
><TD
>t_xx ou T_xx</TD
></TR
><TR
><TD
>Classes</TD
><TD
>@classe</TD
></TR
><TR
><TD
>N'importe quel mot</TD
><TD
>*</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><DIV
CLASS="section"
><HR><H5
CLASS="section"
><A
NAME="AEN140"
>3.1.1.1. Catégories grammaticales</A
></H5
><P
>&#13;            les catégories grammaticales sont définies en utilisant
            les codes symboliques internes au système (type
            L_NOM_COMMUN). La catégorie peut spécifier seulement une
            macro-catégorie ou une paire
            macro-catégorie/micro-catégorie séparées par un tiret.

            exemples: $L_NC, $L_NC-L_NC-GEN sont des spécifications
            correctes de catégories.
          </P
></DIV
><DIV
CLASS="section"
><HR><H5
CLASS="section"
><A
NAME="AEN143"
>3.1.1.2. Classes</A
></H5
><P
>&#13;            Les classes sont définies explicitement dans le fichier
            des règles ou un fichier externe, par une liste des
            éléments de la classe. La syntaxe de la définition d'une
            classe de mots est simplement

            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>@<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>classe</I
></SPAN
>=(<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>unit1</I
></SPAN
>,<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>unit2</I
></SPAN
>,<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>unit3</I
></SPAN
>,...)</I
></SPAN
>

            Les éléments peuvent être n'importe quelle unité définie
            dans la section précédente. La virgule est le séparateur
            entre les éléments, il n'y a pas d'espace après la
            virgule, par contre, des retours à la ligne sont
            autorisés.
            
            Pour l'analyse syntaxique, la définition de classes de
            catégories grammaticale est possible. 
          </P
></DIV
><DIV
CLASS="section"
><HR><H5
CLASS="section"
><A
NAME="AEN151"
>3.1.1.3. Propriétés morphologiques</A
></H5
><P
>&#13;            Les propriétés morphologiques sont identifiés par les
            types donnés aux unités linguistiques par le tokeniseur
            (si les types donnés en sortie du tokeniseur changent, ces
            formalismes des propriétés morphologiques devront être
            modifiés en conséquence).
          </P
><P
>&#13;            Les noms des types sont préfixés (par convention, dans le
            tokeniseur) par "t_" : ce préfixe est utilisé comme pour
            reconnaître directement les noms des types dans les
            règles. Ces types correspondent aux entrées
            "&#60;default&#62;" possibles dans l'automate du tokeniseur.
          </P
><P
>&#13;            A titre d'exemple, les types définis par le tokeniseur du
            français sont les suivants :
            <DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN156"
></A
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><TBODY
><TR
><TD
>t_acronym</TD
><TD
>t_alphanumeric</TD
><TD
>t_capital</TD
><TD
>t_capital_1st</TD
></TR
><TR
><TD
>t_capital_small</TD
><TD
>t_cardinal_roman</TD
><TD
>t_comma_number</TD
><TD
>t_dot_number</TD
></TR
><TR
><TD
>t_fraction</TD
><TD
>t_integer</TD
><TD
>t_ordinal_integer</TD
><TD
>t_ordinal_roman</TD
></TR
><TR
><TD
>t_pattern</TD
><TD
>t_sentence_brk</TD
><TD
>t_small</TD
><TD
>t_word_brk</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
          </P
><P
>&#13;            Les types définis par les tokeniseur des autres langues
            sont également utilisables de manière transparente avec
            cette notation.
          </P
><P
>Une notation structurée des types du tokeniseur est
          également possible (cette notation est considérée obsolète
          parce qu'elle ne permet pas de prendre en compte certains
          types introduits par les nouvelles langues comme l'arabe et
          le chinois, mais elle est encore fonctionnelle et est encore
          utilisée dans les fichiers de règles, c'est pourquoi sa
          spécification est conservée ici).</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN181"
></A
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><TBODY
><TR
><TD
>T_A-</TD
><TD
>alphabétique</TD
><TD
>T_N-</TD
><TD
>numérique</TD
></TR
><TR
><TD
>T_Ac-</TD
><TD
>alphabétique majuscules</TD
><TD
>T_Ni</TD
><TD
>numérique entier</TD
></TR
><TR
><TD
>T_As-</TD
><TD
>alphabétique minuscules</TD
><TD
>T_Nc</TD
><TD
>numérique avec virgule</TD
></TR
><TR
><TD
>T_A1-</TD
><TD
>alphabétique première lettre majuscule</TD
><TD
>T_Nd</TD
><TD
>numérique avec point</TD
></TR
><TR
><TD
>T_Aa-</TD
><TD
>alphabétique acronyme</TD
><TD
>T_Nf</TD
><TD
>numérique fraction</TD
></TR
><TR
><TD
>&#62;T_Am-</TD
><TD
>alphabétique majuscules et minuscules</TD
><TD
>T_No</TD
><TD
>numérique ordinal</TD
></TR
><TR
><TD
>T_A-c</TD
><TD
>alphabétique chiffres romains cardinal</TD
><TD
>T_U</TD
><TD
>alphanumérique</TD
></TR
><TR
><TD
>T_A-o</TD
><TD
>alphabétique chiffres romains ordinal</TD
><TD
>T_P</TD
><TD
>pattern</TD
></TR
><TR
><TD
>T_A-n</TD
><TD
>alphabétique non chiffres romains</TD
><TD
>T_W</TD
><TD
>word break</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>T_S</TD
><TD
>sentence break</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><HR><H5
CLASS="section"
><A
NAME="AEN234"
>3.1.1.4. Indication de la tête d'une expression</A
></H5
><P
>&#13;            La tête d'un expression sera indiquée par le caractère
            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>&#62;&#38;</I
></SPAN
>
            précédant l'unité identifiée comme la tête.
          </P
><P
>&#13;            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>Exemple:</I
></SPAN
>
          </P
><PRE
CLASS="programlisting"
>&#13;abondance:&#38;corne$L_NC d'::IDIOM$Ncfs:corne d'abondance
          </PRE
></DIV
><DIV
CLASS="section"
><HR><H5
CLASS="section"
><A
NAME="AEN241"
>3.1.1.5. Contraintes sur les valeurs numériques</A
></H5
><P
>&#13;            de telles contraintes sont en particulier utiles pour la
            reconnaissance des dates. Elles portent sur les formes
            numériques des nombres et permettent d'indiquer la valeur
            précise souhaitée ou l'intervalle de valeurs souhaité
            (entre <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>m</I
></SPAN
> et <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>n</I
></SPAN
>),
            avec la notation suivante : <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>T_Ni=n</I
></SPAN
> ou
            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>T_Ni&#62;m&#60;n</I
></SPAN
>.
          </P
><P
>&#13;            Note: Ces contraintes devraient être traitées comme des
            contraintes supplémentaires sur une unité (elles
            permettraient de porter sur des unités d'un type autre que
            numérique).
          </P
></DIV
></DIV
><DIV
CLASS="section"
><HR><H4
CLASS="section"
><A
NAME="AEN249"
>3.1.2. Opérations sur les unités simples</A
></H4
><P
>&#13;          Dans le tableau suivant donnant les opérations possibles,
          les éléments indiqués "elt" sont soit des mots, soit des
          groupes (séquences ou alternatives).
        </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN252"
></A
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>&#13;                  <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>Opérations</I
></SPAN
>
                </TH
><TH
>&nbsp;</TH
></TR
></THEAD
><TBODY
><TR
><TD
>séquence (l'un après l'autre)</TD
><TD
>(elt1 elt2 ...)</TD
></TR
><TR
><TD
>alternative (l'un ou l'autre)</TD
><TD
>(elt1|elt2|...)</TD
></TR
><TR
><TD
>élément optionnel</TD
><TD
>elt?</TD
></TR
><TR
><TD
>&#13;                  <P
>cardinalités sur l'occurrence d'un élément : entre
            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>i</I
></SPAN
> et <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>j</I
></SPAN
> fois
            </P
>
                </TD
><TD
>elt{i-j}</TD
></TR
><TR
><TD
>&#13;                  <P
>cardinalités sur l'occurrence d'un élément : entre
            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>i</I
></SPAN
> et un nombre infini de fois
            </P
>
                </TD
><TD
>unité{i-n} ou (...){i-n}</TD
></TR
><TR
><TD
>négation d'une unité (la négation d'un groupe n'étant pas traitée, elle est à éviter)</TD
><TD
>^unité</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>&#13;        </P
></DIV
><DIV
CLASS="section"
><HR><H4
CLASS="section"
><A
NAME="AEN284"
>3.1.3. Bornes de l'expression</A
></H4
><P
>&#13;          L'indication de quelles portions d'expression ne font pas
          partie de l'expression reconnue est donnée en encadrant ces
          portions d'expressions par des crochets <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>[...]</I
></SPAN
>. Ces crochets doivent être placés autour
          des unités ou groupes complets (en particulier, ils
          englobent aussi les modifieurs de groupes indiquant
          l'optionalité d'un groupe).
        </P
><P
>&#13;          Le déclencheur peut ne pas faire partie de l'expression
          reconnue (on placera de la même façon des crochets autour du
          déclencheur).
        </P
></DIV
><DIV
CLASS="section"
><HR><H4
CLASS="section"
><A
NAME="AEN289"
>3.1.4. Type de l'expression</A
></H4
><P
>&#13;          La liste des types possibles sont définis dans un fichier
          externe. Actuellement, les types d'expressions reconnues
          sont tous mis dans le même fichier, qu'elles soient entités
          nommées, expressions idiomatiques, relations de
          dépendance...
        </P
><P
>&#13;          Le champ du type de l'expression peut également contenir des
          informations supplémentaires:
          <P
></P
><UL
><LI
><P
>&#13;                des propriétés linguistiques associées à l'expression
                reconnue: ces propriétés sont utiles lorsque la
                reconnaissance de l'expression doit permettre la
                création d'un nouveau token (c'est le cas pour les
                expressions idiomatiques). L'association de propriétés
                linguistiques se fait en ajoutant le symbole "$" après
                le type de l'expression, suivi du code des propriétés
                linguistiques (ce code doit être le code numérique,
                mais des scripts de compilation permettent de prendre
                en compte le code symbolique à la Grace, comme
                IDIOM$Ncms).
              </P
></LI
><LI
><P
>&#13;                la relativité d'application de la règle (également
                utile pour les expressions idiomatiques) : l'ajout de
                <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>ABS_</I
></SPAN
> devant le type de
                l'expression indique que cette expression est absolue
                (elle est toujours vraie quelle que soit le contexte).
              </P
></LI
><LI
><P
>&#13;                la négation du type: l'ajout de
                <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>NOT_</I
></SPAN
> devant le type de
                l'expression permet d'indiquer que si la règle
                s'applique, aucune autre règle du type indiqué de
                devra être appliquée avec ce déclencheur.
              </P
></LI
></UL
>
        </P
><P
>&#13;          Les types d'expressions définis pour les entités nommées
          sont les suivants :
        </P
><P
>&#13;        </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN304"
></A
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><TBODY
><TR
><TD
>NUMEX</TD
><TD
>pour les nombres et les mesures</TD
></TR
><TR
><TD
>TIMEX</TD
><TD
>pour les dates</TD
></TR
><TR
><TD
>PERSON</TD
><TD
>pour les noms de personnes</TD
></TR
><TR
><TD
>LOCATION</TD
><TD
>pour les noms de lieux</TD
></TR
><TR
><TD
>ORGANIZATION</TD
><TD
>pour les noms d'organisations</TD
></TR
><TR
><TD
>PRODUCT</TD
><TD
>pour les noms de produits</TD
></TR
><TR
><TD
>EVENT</TD
><TD
>pour les événements</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>&#13;          Pour les expressions idiomatiques, un seul type est défini:
          le type IDIOM.
        </P
><P
>&#13;          Pour l'analyse syntaxiques, les types définis correspondent
          aux différents types de relations de dépendance
          considérés. Voici une liste non exhaustive de ces relations
          :
        </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN330"
></A
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><TBODY
><TR
><TD
>DETSUB</TD
><TD
>Relation entre déterminant et substantif (le -&#62; chat)</TD
></TR
><TR
><TD
>ADJPRENSUB</TD
><TD
>Relation entre adjectif prénominal et substantif (beau-&#62;chat)</TD
></TR
><TR
><TD
>COMPADJ</TD
><TD
>Complément d'adjectif</TD
></TR
><TR
><TD
>COMPADV</TD
><TD
>Complément d'adverbe</TD
></TR
><TR
><TD
>ADVADJ</TD
><TD
>Relation entre adverbe et adjectif</TD
></TR
><TR
><TD
>ADVADV</TD
><TD
>Relation entre deux adverbes</TD
></TR
><TR
><TD
>SUBADJPOST</TD
><TD
>Relation entre un substantif et un adjectif postnominal (chat &#60;- noir)</TD
></TR
><TR
><TD
>COMPDUNOM</TD
><TD
>Relation de complément du nom (chat &#60;- Pierre, dans "chat de Pierre")</TD
></TR
><TR
><TD
>SUBSUBJUX</TD
><TD
>Deux substantifs juxtaposés en français</TD
></TR
><TR
><TD
>TEMPCOMP</TD
><TD
>Temps composé</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>&#13;        </P
></DIV
><DIV
CLASS="section"
><HR><H4
CLASS="section"
><A
NAME="AEN364"
>3.1.5. Forme normalisée de l'entité</A
></H4
><P
>&#13;          La forme normalisée de l'expression est simplement donnée
          comme une chaîne de caractères. Pour les types dont la forme
          normalisée doit être calculée, un code peut être donné,
          indiquant la façon de dont cette normalisation doit être
          faite. Les codes actuellement définis sont les suivants :
        </P
><P
>&#13;        </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN368"
></A
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><TBODY
><TR
><TD
>N_DATE</TD
><TD
>normalisation des dates en jour, mois, année</TD
></TR
><TR
><TD
>N_NUMBER</TD
><TD
>normalisation des nombres (calcul de la valeur de nombres en toutes lettres)</TD
></TR
><TR
><TD
>N_PERSON</TD
><TD
>normalisation des noms de personnes en nom, prénom, titre</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>&#13;          Dans une version ultérieure des règles, ces normalisations
          devraient utiliser les actions.
        </P
><DIV
CLASS="section"
><HR><H5
CLASS="section"
><A
NAME="AEN381"
>3.1.5.1. Contraintes et actions</A
></H5
><P
>&#13;            Des contraintes ou des actions peuvent être attachées aux
            règles de reconnaissance d'expressions.  
            
            Les contraintes peuvent porter sur un ou deux éléments de
            la règle: elles correspondent à une fonction qui sera
            appelée avec en argument le ou les deux noeuds des
            éléments correspondant et qui renvoie un booléen.

            Les actions sont des fonctions appelées à la fin de
            l'application de la règle, en fonction du succès de la
            règle (est-ce que l'expression a été reconnue ou non).
            Elles n'utilisent pas les éléments de la règle. Elles
            peuvent éventuellement utiliser le résultat produit par la
            règle (ceci est décidé à l'écriture de la fonction, et
            n'est pas indiqué directement dans la règle).
          </P
><P
>&#13;            Par souci de lisibilité des règles, les contraintes entre
            des éléments d'une règle et les actions sont exprimées à
            l'extérieur de la définition des règles.
          </P
><P
> 
            A la suite des règles (ou dans les lignes suivantes), les
            contraintes commencent par un <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>+</I
></SPAN
>, et
            s'ecrivent :
          </P
><P
>&#13;            +constraintName(elt1,elt2,"complement")
          </P
><P
>ou</P
><P
>&#13;            +constraintName(elt,"complement")
          </P
><P
>&#13;            Dans le premier cas, les <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>elt1</I
></SPAN
> et
            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>elt2</I
></SPAN
> sont les éléments sur lesquels
            portent la contrainte, le complément (entre guillemets),
            est optionnel et peut être utilisé pour passer une
            information supplémentaire à la fonction.
          </P
><P
>&#13;            Dans le second cas, <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>elt</I
></SPAN
> est le seul
            élément sur lesquel porte la contrainte.
          </P
><P
>&#13;            Les éléments sont repérés par leur position dans la règle,
            en deux temps : d'abord, le contexte, qui peut être
            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>right</I
></SPAN
> (contexte droit),
            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>left</I
></SPAN
> (contexte gauche) ou
            <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>trigger</I
></SPAN
> (déclencheur), puis la
            position du mot dans le contexte (l'indication des
            positions des mots est pour le moment très limitée: on
            peut seulement accéder à des éléments simples dans le
            contexte: les groupes de mots sont comptés comme un
            élément)
          </P
><P
>&#13;            Exemple:

            pour le cas des verbes pronominaux, si l'on veux faire la
            distinction entre "je m'arrête", "je t'arrête", "tu
            m'arrêtes", "tu t'arrêtes") : on peut alors utiliser une
            règle intégrant des contraintes d'accord :
          </P
><PRE
CLASS="programlisting"
>&#13;arrêter$L_V:$L_PRON-L_PRON_REFLEXIF @PronPrev[$?]::IDIOM$V:s'arrêter
+AgreementConstraint(trigger.1,left.1,"PERSON")
+AgreementConstraint(trigger.1,left.1,"NUMBER")
          </PRE
><P
>&#13;            où <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>@PronPrev</I
></SPAN
> est la classe des
            catégories des pronoms personnels préverbaux.
          </P
><P
>&#13;            Les actions sont définies à la suite des règles (ou dans
            les lignes suivantes), par un <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>=</I
></SPAN
>,
            suivi d'un signe &#62; ou &#60; et du nom de la fonction.
            <P
></P
><UL
><LI
><P
> =&#62;faitQuelqueChose() indique que
              l'action <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>faitQuelqueChose</I
></SPAN
> sera
              effectuée en cas de succès d'application de la règle;
              </P
></LI
><LI
><P
> =&#60;faitAutreChose() indique que
              l'action <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>faitAutreChose</I
></SPAN
> sera
              effectuée en cas d'échec d'application de la règle;
              </P
></LI
></UL
>
            Comme pour les contraintes, des compléments peuvent être
            passés à la fonction.
          </P
></DIV
></DIV
><DIV
CLASS="section"
><HR><H4
CLASS="section"
><A
NAME="AEN412"
>3.1.6. Compléments de syntaxe des fichier de règles</A
></H4
><P
>&#13;          L'utilisation d'un caractère d'échappement (\) permet
          d'introduire dans la définition des unités les caractères de
          la syntaxe " :()[]{}^|@$&#38;", sans qu'ils soient
          interprétés.
        </P
><P
>&#13;          D'autre part, pour permettre de rendre les fichiers de
          règles plus structurés et plus lisibles, les éléments de
          syntaxe suivants ont également été définis :
        </P
><P
>&#13;        </P
><P
></P
><UL
><LI
><P
>&#13;              les lignes commençant par " <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>#</I
></SPAN
> "sont
              des commentaires (un " <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>#</I
></SPAN
> "qui n'est
              pas en début de ligne n'est pas interpété comme un
              commentaire) ;
            </P
></LI
><LI
><P
>&#13;              la primitive "<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>include</I
></SPAN
>" suivie d'un
              nom de fichier (ou de plusieurs noms de fichiers séparés
              par des virgules) permet d'inclure des fichiers de
              règles externe (ces fichiers sont interprétés de façon
              complètement indépendante: par exemple, les classes
              définies dans les fichiers inclus ne sont pas accessibles
              dans le fichier incluant, ni le contraire);
            </P
></LI
><LI
><P
>&#13;              la primitive "<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>use</I
></SPAN
>" suivie d'un nom
              de fichier (ou de plusieurs noms de fichiers séparés par
              des virgules) permet d'inclure des définitions de
              classes de mots externes: les classes
            </P
></LI
><LI
><P
>&#13;              une indication de l'encodage du fichier peut être faite
              au début du fichier, par la primitive "<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>define encoding=</I
></SPAN
>". Les seuls codages possibles sont
              pour l'instant "latin1" et "utf8". Le codage par défaut
              est "latin1" (l'indication doit être placée avant la
              première ligne qui pourrait être mal codée).
            </P
></LI
><LI
><P
>&#13;              dans le but de rendre plus générique l'application des
              règles, il est possible d'associer une action par défaut
              à toutes les règles d'un fichier. Cela se fait avec la
              primitive "<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>set defaultAction=</I
></SPAN
>"
              suivie d'un nom d'action.
            </P
></LI
></UL
><P
>&#13;        </P
></DIV
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN435"
>3.2. Spécification formelle des règles</A
></H3
><P
>&#13;        La grammaire EBNF décrivant la définition des règles est
        présentée dans cette section.
      </P
><PRE
CLASS="programlisting"
>&#13;        
&#60;définition&#62;      ::= { &#60;règle&#62; }
&#60;règle&#62;           ::= &#60;déclencheur&#62; ":" &#60;contexteGauche&#62; ":"
                      &#60;contexteDroit&#62; ":" &#60;type&#62; ":" &#60;formeNormalisée&#62; 
                      [&#60;contrainte&#62;*] [&#60;action&#62;*]
&#60;déclencheur&#62;     ::= ["["] &#60;unitéSimple&#62; ["]"]
&#60;contexteGauche&#62;  ::= { &#60;élément&#62; }
&#60;contexteDroit&#62;   ::= { &#60;élément&#62; }
&#60;type&#62;            ::= &#60;Chaîne&#62; [&#60;catégorie&#62;]
&#60;formeNormalisée&#62; ::= &#60;Chaîne&#62;
&#60;contrainte&#62;      ::= "+" &#60;nomFonction&#62; "(" &#60;eltIndex&#62; [, &#60;eltIndex&#62;] 
                      [, "\"" &#60;Chaîne&#62; "\""] ")"
&#60;action&#62;          ::= "=" &#60;actionAppl&#62; &#60;nomFonction&#62; 
                      "(" ["\"" &#60;Chaîne&#62; "\""] " )"
&#60;nomFonction&#62;     ::= &#60;Chaîne&#62;
&#60;actionAppl&#62;      ::= "&#62;" | "&#60;"
&#60;eltIndex&#62;        ::= &#60;part&#62; "." &#60;index&#62;
&#60;part&#62;            ::= "trigger" | "left" | "right"
&#60;index&#62;           ::= &#60;Entier&#62;
&#60;élément&#62;         ::= ["["] [&#60;modifieurPre&#62;] &#60;unitéComplexe&#62; 
                      [&#60;modifieurPost&#62;] ["]"]
&#60;unitéComplexe&#62;   ::=  &#60;unitéSimple&#62; | &#60;groupe&#62; | &#60;alternative&#62;
&#60;groupe&#62;          ::= "(" &#60;unitéComplexe&#62;* ")"
&#60;alternative&#62;     ::= "(" &#60;unitéComplexe&#62; ("|" &#60;unitéComplexe&#62;)+ ")"
&#60;unitéSimple&#62;     ::= ["&#38;"] &#60;motGénéralisé&#62;
&#60;motGénéralisé&#62;   ::= &#60;motSimple&#62; [ &#60;catégorie&#62; ] | &#60;catégorie&#62; | 
                      &#60;classe&#62; | &#60;Tstatus&#62;
&#60;modifieurPre&#62;    ::= "^"
&#60;modifieurPost&#62;   ::= "?" | "{" &#60;cardinalité&#62; "-" &#60;cardinalité&#62; "}"
&#60;cardinalité&#62;     ::= &#60;Entier&#62; | 'n' | 'N'
&#60;motSimple&#62;       ::= &#60;ChaîneSansBlanc&#62; | "*"
&#60;catégorie&#62;       ::= "$" &#60;Chaîne&#62;
&#60;classe&#62;          ::= "@" &#60;Chaîne&#62;
&#60;Tstatus&#62;         ::= ""t_" &#60;Chaîne&#62; | T_" &#60;propriétéMorphologique&#62; 
&#60;propriétéMorphologique&#62; ::= 'A' &#60;MorphoAlphaCap&#62; &#60;MorphoAlphaRoman&#62; | 
                             'N' &#60;MorphoNumeric&#62; | 'U' | 'P' | 'W' | 'S'
&#60;MorphoAlphaCap&#62;         ::= 'c' | 's' | '1' | 'a' | 'm'
&#60;MorphoAlphaRoman&#62;       ::= 'c' | 'o' | 'n'
&#60;MorphoNumeric&#62;          ::= 'i' | 'c' | 'd' | 'f' | 'o'
        
      </PRE
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN439"
>3.3. Limites</A
></H3
><P
>&#13;      </P
><DIV
CLASS="section"
><HR><H4
CLASS="section"
><A
NAME="AEN442"
>3.3.1. Limites d'expressivité des règles</A
></H4
><P
>&#13;          Le formalisme défini ici ne permet pas d'exprimer  :
        </P
><P
></P
><UL
><LI
><P
>&#13;              le groupement de plusieurs propriétés pour une seule
              unité : le formalisme actuel ne permet pas de spécifier
              qu'une unité doit être de plusieurs types à la fois (on
              ne peut pas exprimer par exemple qu'une unité doit être
              un mot commençant par une majuscule et un nom propre).
              On peut seulement ajouter ça dans des contraintes
              extérieures.
            </P
></LI
><LI
><P
>&#13;              la négation d'un groupe de mots : la négation d'un
              groupe complexe de mots (succession ou alternative)
              introduit des problèmes supplémentaires car elle ne se
              traduit pas simplement par un distribution de la
              propriété de négation sur chacun des éléments (ce que
              fait l'implémentation actuelle) :
            </P
><P
></P
><UL
><LI
><P
>&#13;                  pour les alternatives : l'expression
                  <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>not(a|b)</I
></SPAN
> est interprétée comme
                  <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(not(a)|not(b))</I
></SPAN
>, ce qui est
                  faux.  L'implémentation de cette fonction demande
                  donc également la conjonction de propriétés au
                  niveau d'une unité ;
                </P
></LI
><LI
><P
>&#13;                  pour les groupes : l'expression <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>not(a b)</I
></SPAN
> est interpétée comme <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(not(a) not(b))</I
></SPAN
> alors qu'elle devrait être
                  interprétée comme <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>(not(a b)|a not(b))</I
></SPAN
>.
                </P
></LI
></UL
></LI
><LI
><P
>&#13;              La définition de sous-automates serait un outil utile
              pour le développement des règles, mais n'est pas
              implémentée.
            </P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="AEN462"
>3.4. Exemples de règles</A
></H3
><P
>&#13;      </P
><DIV
CLASS="section"
><HR><H4
CLASS="section"
><A
NAME="AEN465"
>3.4.1. Règles de reconnaissance des entités nommées</A
></H4
><P
>&#13;          Voici un exemple de quelques règles simples pour la
          reconnaissance des noms de journaux français :
        </P
><PRE
CLASS="programlisting"
>&#13;Libération:::ORGANIZATION:
Monde:Le:Diplomatique:ORGANIZATION:
Monde:Le:de l'Education:ORGANIZATION:
Monde:Le::ORGANIZATION:
Courrier::International:ORGANIZATION:
Canard::Enchaîné:ORGANIZATION:
        </PRE
><P
>&#13;          Un autre exemple de règles, plus complexes, pour la reconnaissance des noms de personnes  :
        </P
><PRE
CLASS="programlisting"
>&#13;@Firstname:[(@Title|@FunctionTitle)?]:((de|da|le)? T_A1){1-2}:PERSON:N_PERSON
T_A1:[(@Title|@FunctionTitle)]:T_A1{0-2}:PERSON:N_PERSON
T_A1:(T_A1|T_Amh){0-2}:, @FunctionTitle:PERSON:N_PERSON
        </PRE
><P
>&#13;          La première de ces règles se déclenche sur un prénom
          (la liste des prénoms est explicitement définie dans
          le fichier des règles), le contexte gauche contient,
          de façon optionnel, un titre (M., Mme, Dr, ...) ou
          une fonction (président, député,...), qui n'est pas
          gardé dans la règle finale ; le contexte doit est
          composé d'un ou deux mots commençant par une
          majuscule, éventuellement précédé de " de ", " da
          "ou " le ".
        </P
><P
>&#13;          La seconde reconnaît les noms de personnes
          introduits par des titres ou des noms de fonctions,
          mais sans indication de prénom.
        </P
><P
>&#13;          La troisième reconnaît des noms de personnes dont la
          fonction est mise en apposition postérieure (par
          exemple, " Sanjiv Sidhu, président d' i2
          Technologies ").
        </P
><P
>&#13;          Voici un autre exemple de règles, pour la
          reconnaissance de dates, déclenchées sur les noms de
          jours ou de mois :
        </P
><PRE
CLASS="programlisting"
>&#13;# lundi 22 mai 1968
$L_NC-L_NC_JOUR::T_Ni&#62;1&#60;31 $L_NC-L_NC_MOIS (T_Ni&#62;1000&#60;3000|T_Ni&#62;1&#60;99)?:TIMEX:N_DATE
# 22 mai 1968
# 18 juin 40
# 31 octobre prochain
$L_NC-L_NC_MOIS:(T_Ni&#62;1&#60;31)?:(prochain|dernier|suivant|(T_Ni&#62;1000&#60;3000|T_Ni&#62;1&#60;99))?:TIMEX:N_DATE
        </PRE
><P
>&#13;        </P
></DIV
><DIV
CLASS="section"
><HR><H4
CLASS="section"
><A
NAME="AEN477"
>3.4.2. règles de reconnaissance des expressions idiomatiques</A
></H4
><P
>&#13;          Voici des exemples de règles pour la reconnaissance
          des expressions idiomatiques du français :
        </P
><PRE
CLASS="programlisting"
>&#13;&#38;arrêter$L_V:$L_PRON-L_PRON_REFLEXIF @PronPrev[$?]::IDIOM$V:s'arrêter
+AgreementConstraint(trigger.1,left.1,"PERSON")
+AgreementConstraint(trigger.1,left.1,"NUMBER")
fur:au:et à mesure (de|d'):IDIOM$Sg:au fur et à mesure de
fer:&#38;rideau de::IDIOM$Nc:
        </PRE
><P
>&#13;          où <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>$Sg</I
></SPAN
> indique une préposition
          générale.
        </P
></DIV
></DIV
></DIV
></DIV
></BODY
></HTML
>