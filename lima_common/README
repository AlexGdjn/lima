Les instructions d'installation sont dans le fichier INSTALL de ce repertoire.
Il peut aussi etre judicieux de lire le fichier README de s2ressources_64bits
(comment? vous ne l'avez pas encore telecharge !? Il faudrait...)

Portage sur environnement 64 bits
=================================
S2 (s2common, s2lp, s2index, s2reformulator, s2searchengine) a été porté sur machine 64 bits et mergé sur le HEAD.

Environnement
------------
La version du driver firebird (ibpp) a du être changée.
La compatibilité sur machine 64 bits nécessite une version plus récente du driver que celle couramment déployée. L'API a légèrement changée et n'est pas compatible de façon ascendante. Je préfère donc que tout le monde s'aligne sur cette version plus récente, pour ne pas avoir à prendre en compte des API différentes dans le code client.
Si vous ne faites pas le changement, cela se traduit par une erreur sur les appels
statement->Transaction() qui remplacent statement->TransactionPtr()

récupérer ibpp-2-5-3-1-src.zip sur le site de SourceForge http://sourceforge.net/project/showfiles.php?group_id=9514
Hervé a un descripteur de make (Makefile) dans /mnt/linux_data/s2/external-workspace/archive/ibpp/tests/unixes qui construit la librairie libibpp.so. Je rappelle que les librairies Firebird doivent être disponible pour cette fabrication.

Il n'y a pas d'autres précautions particulières à prendre.

Code source
-----------
Il a fallu changer un certain nombre de choses dans les sources pour réussir à compiler le même code sur les 2 architectures

L'une des difficultés provenait d'un certain nombre de déclaration de type ambiguës:
int signifie entier 64 bits sur une architecture 64 bits et 32 bits sur une architecture 32 bits.
(Attention! Cela ne dépend pas du processeur mais du compilateur.)
tandis que:
int64_t signifie toujours un entier 64 bits, quelle que soit l'architecture. 

Le travail a consisté essentiellement à modifier le code pour résoudre les erreurs de compilation.
En effet, de temps en temps dans le code, on effectuait des affectations d'une variables de type int32_t à partir d'une expression de type int. Cette erreur est signalée lorsqu'il y a un risque de perte de données par troncature.
Par exemple, sur une architecture 64 bits, la variable de type int est sur 64 bits et risque d'être tronquée.

On a surtout eu des modifications à faire sur nos structures de données quand elle gèrent des données issues des structures de données issues du code boost/graph. En effet les descripteurs de noeuds sur boost sont déclarés à partir d'un type implicite ambigu. Ils font 32 bits sur une architecture 32 bits et 64 bits sur une architecture 64 bits.

Par exemple dans le source s2lp/src/linguisticProcessing/core/Compounds/BowGeneration.cpp:462,
Il a fallu remplacer des déclarations comme
std::set< uint64_t > anaVertices ou
std::set< uint32_t > anaVertices par
std::set< AnnotationGraphVertex > anaVertices
AnnotationGraphVertex est le type implicite déclaré dans boost qui se propage dans notre code.

Après avoir compilé sur les 2 architectures le même code et fabriqué les ressources sur les 2 architecture, il y a eu très peu d'interventin pour que touts les tests unitaires fonctionnent.

L'erreur d'éxécution la plus fréquente concerne les types implicites aussi string::size_type

exemple:
dans le code
const Lic2mString str;
unsigned int i(str.find(m_separator));
if (i == string::npos)
il faut remplacer la déclaration i par 
string::size_type i(str.find(m_separator));
sinon le test risque d'être toujours faux.

Stratégie
---------
On peut considérer qu'il y a :
1) des structures de données que nous avons définis. Nous sommes complètement maîtres des types utilisés à ce niveau pour les définir. On va les appeller les structures de données S2.
2) des structures de données hérités des librairies externes (boost:graph par exemple). On va les appeller les structures de données external.

Il se trouve que certaines structures de données external sont basées sur des types implicites liés à l'architecture.

Le choix qui a été fait est de propager dans les structures de données S2 ces ces types implicites hérités des structures de données external.
Le deuxième choix aurait été de contrôler complètement au niveau des structures de données S2 les tailles des types (en utilisant systématiquement des types définis à partir de uint16_t, uint32_t, uint64_t)
et de faire des conversion explicites d'un type external à un type S2 ou l'inverse.

Choix 1: type implicites propagés
L'avantage est de bénéficier sur une architecture 64 bits d'une plus grande dynamique pour les types entier, et de ne plus êrtre limités (par exemple nombre de documents limités à 2 millards, nombre de termes dans le lexique limité à 2 milliard, etc.)
Par ailleurs, il y a moins de code à changer.
L'inconvénient est que les données prennent plus de place.
En fait les types implicites int passent de 4 à 8 octets, alors que toute la dynamique n'est pas utilisée sur les volumes d données que nous pratiquons actuellelement. Les alignements de structure se font aussi sans doute sur 8 octets et il y a sans doute aussi beaucoup de perte de mémoire à ce niveau.

Choix 2: types S2 complètement contrôles.
On limite la dynamique des données aux valeurs que nous pratiquons effectivement. On ets plus économiques en mémoire. Par contre il y a plus de code à changer.

Pour information, de ce qui a été mesuré jusque là, les processus prennent entre 30% et 100% de place en plus.
Ce n'est pas négligeable!

Conséquence pour les ressources:
On garde les types implicites quand on fait les entrées sorties des ressources, avec typiquement du code qui utilise sizeof(int). La conséquence est que les ressources ne sont pas compatibles d'une architecture à une autre.
Si on avait fait le choix 2, on aurait été naturellement poussé à garder des ressources compatibles.
Il faut compiler les ressources sur la même architecture que la machine sur lesqueles elles vont être utilisées.

Pour info la commande pour le merge utilisée:
svn merge -r nn:HEAD $SVNROOT/branches/s2common/s2common_64bits
nn est le numéro de version au moment ou a été créé la branche

